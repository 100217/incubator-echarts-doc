# WebGL 在数据可视化中的实践

Note:
这次分享我会先大概介绍 echarts 这个产品，然后主要介绍我们最近尝试用 WebGL 实践数据可视化中碰到的一些问题和解决方案。
具体的可视化方面的知识也会穿插着介绍。

---

## ECharts 简介

ECharts 是基于 Canvas 的一个开源的前端可视化库，提供了

+ 声明式的编程接口

+ 丰富的可视化类型和交互方式

+ 大数据量展现的能力

+ 吸引眼球的动画和特效

----

## ECharts 简介

+ GitHub 关注数 ~16k

+ 官网访问量 ~300k pv

## 为什么选择 Canvas？

----

## Canvas 的瓶颈

---

## WebGL ?

Note:
对 echarts 有所了解的同学应该知道两年前出 echarts-x，echarts-x 是我们在 echarts 产品中对 WebGL 的首次尝试，其中获取了不少经验，也碰到了不少问题，比如在 echarts 2 的架构下对于新图表的扩展其实比较受限，所以当时只做了一个 globe visualization 就没做下去了。后来我们设计 echarts 3 架构的过程中把可扩展性作为很重要的一个点，会考虑是否能够去扩展底层新的图形接口，是否能够扩展新的坐标系，新的图表和组件等等。

----

## WebGL 能够带来什么

+ 更加酷炫的特效
+ 绘制三维图表
+ 加速二维图表的绘制
+ GPGPU 进行布局的加速

Note:
还有更多的可能性

---

## 三维图表

Note:
echarts 支不支持三维图表的绘制已经是 github 上的一个月经贴了。其实大部分时候我们都会推荐用二维的可视化方式。比如传统的折柱散点图。因为这些图表达数据是最清晰的。

但是三维还是有优势和使用场景的，比如说三维的图表可以做得很抓眼球，例如通过大数据的分散聚合效果，空间视角的切换让人眼花缭乱。

而且因为多了一个维度多展示一维的数据，有些场景中可以让我们更多角度更沉浸的去探索数据

----

## 三维中点线面的绘制

Note:
点线面是可视化中常见的图形元素。也是我们组成可视化三维空间中各个图形的基础图元。

下面会分别来说我们在 WebGL 绘制点线面的时候碰到了哪些问题以及怎么解决的。

---

## 点

Note:
打点是最常见的一种数据可视化方式，比如刚刚的微博签到图就通过在地图打点的方式标出不同地区微博的使用程度。

同时打点也是常见的一个很多人会用 WebGL 加速绘制的对象。因为其实现简单，见效快。

----

#### JavaScript
```javascript
gl.drawArrays(gl.POINTS, 0, 100);
```

#### Vertex
```glsl
gl_PointSize = 5;
```

#### Fragment
```glsl
gl_FragColor = vec4(1.0);
```

----

## 不同形状的点

+ 把形状用白色填充到 Canvas 上作为纹理

```glsl
gl_FragColor = color * texture2D(sprite, gl_PointCoord);
```

----

## 描边？

Note:
描边可以继续

----

## Signed Distance Field

Note:
这里我用 echarts 的热力图把 Signed Distance Field 的结果画出来了

---

## 线

----

## 原生态画线

```javascript
gl.lineWidth(5);
gl.drawArrays(gl.LINES, 0, 100);
```

+ gl.LINES
+ gl.LINE_STRIP
+ gl.LINE_LOOP

Note:
跟刚才画点一样，WebGL 本身也支持画线的模式，而且还支持多中画线的配置

----

## 但是

----

## 原生画线方法的各种坑

+ 不同的驱动下画线的效果会有细微区别
+ 无法控制 `lineJoin` 和 `lineCap`
+ **有最大线宽的限制，而且 Windows 下最大只有 1**

Note:
windows 下因为 ANGLE 的原因最大线宽只有 1

----

## 三角化线段


----

## 实现屏幕空间固定宽度

Note:
如果是在传入 GPU 之前就把顶点构建好，没法实现屏幕空间宽度，也就是没办法保证视角放大缩小后线宽是一致的。
需要在顶点着色器中移动顶点实现屏幕空间的宽度。

----

## Miter Limit

---

## 面

----

## 三角面

----

## 参数曲面

----

## Geo3D

---

## 实现高质量的画面

----

## 不要廉价的三维效果

Note:
很多人排斥三维的可视化还有一个原因是因为很多三维的可视化效果渲染效果十分廉价，比如这张柱状图，还有这张地球。充斥着经典的 phong 模型的高光和其所带来的塑料感。

但是做得好的三维可视化还是能令人赏心悦目的。

----

## 一些提高画质的手段

+ 半透明
+ 真实感渲染
+ 粒子特效

Note:
风格化是为了让用户能够通过一些简单的配置项，轻松实现出那些具有艺术感的可视化作品。

---

## 半透明

----

## 对大量三角面片渐进排序

---

## 真实感渲染


----

## Physically Based Rendering

Note:
现在游戏里基本上普遍使用了基于物理的渲染，

----

## 阴影

----

## Temporal SSAO

----

## HDR

---

## 粒子效果

---

## Temporal AA

---

## 二维图表的加速

+ 地理上的点数据和线数据
+ GPGPU 加速力引导布局

Note:
点数据和线数据的渲染前面已经提了挺多的了，接下来主要讲我们使用 GPGPU 加速力引导布局的一个尝试

----

## 力引导布局介绍

+ 用于关系图
+ 节点与节点之间模拟斥力，边模拟弹簧的引力
+ 每次迭代 O(n2), 需要上百次迭代才能结束

Note:
力引导布局是用于关系图布局的经典算法， 有很多种算法和实现，但是其基本原理都是一样的，都是节点与节点存在一个电荷的斥力，边则存在一个弹簧的引力。每次迭代通过计算每个节点的受力，并且根据受力产生一个位移，在多次迭代后整个布局的能量会趋向一个平衡，关系边多的节点间有一个聚类的趋势。

所以传统的力引导算法开销很大，因为要有上百次，每次都是 O(n2) 受力计算才能结束。为了防止布局的阻塞给用户带来的困扰，我们多会把布局过程表现出来，刚好这个动画也挺有意思的。

这个是 echarts 的力引导布局。

----

## 力引导布局的性能优化

+ Barnes Hut Simulation
+ SIMD？
+ 多线程？

Note:
在算法层面力导向布局最常见的性能优化方式就是这个 Barnes Hut Simulation，它把所有节点放到一个四叉树里，然后对于一批距离远的节点可以看做一个整体计算斥力。而不用去一个点一个点的算。

在程序层面，可以通过 SIMD，多线程等方式去并行计算，也可以带来可观的优化效果。

但是 JS 里对 SIMD 和多线程的支持并不好。所以这一块优化很难做

----

## GPGPU 加速

----

---


## 在现有架构中集成 WebGL

----

## 扩展图形接口

----

## 与现有的组件集成

----

## 交互

---

谢谢！

---
